Achieving isolation

Achieving serializability
  Potential anomalies from concurrent transactions not properly isolated
    Different isolation levels prevent
    Stronger isolation = more anomalies prevented, lose performance
  Strictly serializable necessary to avoid *all* anomalies
    Strongest isolation level
  Serializability
    Next strongest
    Guarantees results of any allowed transaction execution
    Same as that produced by some serial execution of same transactions
  Schedule
    Execution of multiple transactions that correspond to ordering of operatoions
  Two types of serializability
    View serializability
    Conflict serializability
  View serializability
    Schedule is a view equivalent to a serial schedule with the same transactions
      when all operations from transactions in two schedules read & write same data values
      "view" same data
  Conflict serializability
    Every pair of conflicting operations between transactions ordered same in both schedules
  Calculating whether schedule is view serializable is NP-complete
    Time required to solve grows rapidly as size of problem grows
    Will not analyze view serializability further
  Conflict serializability much easier to solve
    So is widely used
    Operations conflict if
      Belong to different transactions
      On same data item
      At least one is a write operation
        Write - inserts, modifies, or deletes object
    As a result, 3 kinds of conflict
      Read-write conflict
      Write-read conflict
      Write-write-conflict
    Check if schedule is conflict serializable
      Trivial
        Check all possible schedules, identify conflicting operations
        Check if order same as in schedule under examination
        Computationally heavy
          Must comput all possible permutations of transactions
      Precedence graph
        More practical
        Directed graph
          Nodes = transactions
          Edges = conflicts between ops
        Edges denote order in which transactions must execute in serial schedule
        Schedule is serializable iff precedence graph is acyclic
        (Examples)
          Cycle = not conflict serializable
          Can be multiple orders that work sometimes!
    Need a way to generate schedule ahead of time
      Notion of precdence graph is beneficial
      Ensure no cycle formed as execute operations - either:
        1. Prevent transactions from making progress when risk of conlict creating cycle
        2. Let transactions execute and check if committing could introduce a cycle
          If so abort and restart
  Two main mechanisms for concurrency controls
    Pessimistic
      Blocks transaction if expected to cause violation of serializability
      Resumes when safe to do so
      Have transactions acquire locks on data they process, prevent others from processing
      "Pessimistic" because assumes most transactions will conflict
    Optimistic
      Delays checking until end of transaction
      Abort if commit will violate serializability rules
      Assumes most transactions will not have conflicts
    Tradeoff:
      Pessimistic overhead from locking mechs
      Optimistic wasted computation from aborted transactions
    Optimistic methods perform well when not many conflicts
      Many read-only transactions, only a few writes
      Most transactions touch different data
    Pessimistic better when lots of transactions conflict

Pessimistic concurrency control (PCC)
  2-phase locking
    Two basic types of locks: write "exclusive" and read "shared"
    A read lock does not block a read from another transaction
      Multiple read locks can be acquired at same time
    A read lock blocks a write from another transaction
      Must wait until read lock is released
    A write lock blocks both writes and reads - hence "exclusive"
    If a lock blocks: "incompatible"
      All but read-read in 2PL
    If a lock does not block: "compatible"
      Only read-read in 2PL
    Transactions acquire locks only in expanding phase
    Transactions release locks only in shrinking phase
    Note may need to be able to lock ranges of records (predicate locking)
      Prevent anomalies like phantom reads
    A schedule generated by 2PM will be conflict equivalent to a serial schedule
      Transactions serialized in order completed expanding phase
    Slight variations
      Strict 2PL
      Strong strict 2PL
  Deadlocks
    Introduces risk for deadlocks
    Two transactions both hold a resource the other needs
    Two ways to deal with
      Prevention
      Detection
    Prevention
      Know all locks needed in advance, acquire in ordered way
        Typically done by application
        Many databases support interactive transactions
          are unaware of all data a transaction will process
    Detection
      Keep track of which transaction a transaction waits on
      Detect cycles that represent deadlocks
        Force one of transactions to abort
      Typically done by database, app does not need to do anything extra

Optimistic concurrency control (OCC)
  First proposed 1981
  Three phases
    Begin
    Read & modify
    Validate & commit/rollback
  Begin
    Assign unique timestamp marking transaction beginning
  Read & modify
    Execute read and write tentatively
    When item modified, copy of item written to temp local storage
      Read operation checks for copy and returns if exists
        If not, performs regular read
  Validate and commit/rollback
    Once all operations executed
    Check whether other transactions have modified data and started after
      Abort and restart acquiring new timestamp
    Commit = copy all values from write from local storage to common database storage
    Must be performed in a single atomic action - part of a critical section
      Requires some form of locking mechanism
      Various optimizations to reduce duration for performance
  How to implement validation logic
    Version check
      Every data item marked with version number
        Transaction keeps track
      Check if version number remains same during validation phase
        If so, no other transaction has accessed
    Timestamp ordering
      Transaction keeps track of items accessed by read or write
        "read set" and "write set"
      Validation time: in critical section
        Record fresh timestamp "finish timestamp"
        Iterates over all transactions assigned timestamp between start and finish
        If their write set interscts with read set
          Transaction has read a value "from the future"
          Abort and restart from beginning

Snapshot Isolation
  Mutli-version concurrency control MVCC
    Technique where multiple physical versions are maintained for a single logical data item
      Update operations do not overwrite existing records, write a new version
      Read operations can then select a specific version, possibly an older one
      Contrast to previous techs - where update performed in place, single record for each data item
    Proposed 1978, variations since then
    Can be used - theoretically - with both optimistic and pessimistic schemes
      Most variations use OCC to leverage multiple versions of item from concurrent transactions
  Achieving snapshot isolation with MVCC
    Guarantee all reads in transaction see consistent snapshot from start point
    Commits successfully if no transaction updates since snapshot
      Easier to achieve snapshot isolation via MVCC
  How
    Assign transaction unique timestamp to start
    Every entry for item has a version corresponding to timestamp of transaction creating
    Every transaction records at beginning:
      Highest timestamp transaction committed so far (Ts)
      Number of active transactions started but not committed
    Performing reads
      Returns entry latest version earlier than Ts and not belonging to transaction active at beginning
        Unless transaction has already updated item - return that value instead
        Prevents dirty reads
        Prevents fuzzy reads
          All reads return from same snapshot, ignore values from after
    Performing writes
      Checks whether entry for same item:
        Version higher than this transaction's timetamp
        Version lower but belongs to active transaction
          Prevent lost update anomaly
      If so, abort and start with larger timestamp
      Prevents a lot of anomalies but still not serializable
        Some anomalies still possible
  Write skew
    None of transactions sees versions written by other transaction
      Not possible in a serial execution

Full serializable snapshot isolation
  Improved algorithm, now widely used in commercial databases
  Still optimistic, adds extensions on top of prior setup
  All non-serializable executions before had a common characteristic
    Contain two consecutive transactions with a rw-dependency
  SSI approach detects cases and breaks cycle when about to happen
    Keeps track of incoming and outgoing rw-dependency edges of each transaction
    If transaction with both incoming and outgoing edges, abort and retry later
    Can lead to false-positive aborts!
      Does not check for cycle
        Avoid computational costs
    Maintain two Boolean flags per transaction
      T.inConflict
      T.outConflict
    How to maintain flags
      When performing read, can detect whether version of same item written later
        Imply rw-depedency edge, update outConflict and inConflict to true
        Does not detect cases where write after read
      Every transaction creates read lock - SIREAD lock, when performs read
        When performing write, look for existing SIREAD locks and detect concurrent transactions
        Softer form of locks
          Do not block other transactions from operating
          Exist to signal dependencies between them
          Therefore algorithm preserves optimistic nature
  Preventing write-skew abnormality

