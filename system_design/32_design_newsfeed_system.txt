Newsfeed system
  List of stories generated by entities a user follows
    Page, group, friends, etc.
  Contains
    Text
    Images
    Videos
    Likes
    Comments
    Shares
    Ads
    etc.
  Continuously updated & shown on homepage
  Essential for social media
    Keeps users informed about latest developments
    Reason to come back regularly
    Billions of users
  Challenge
    Personalization
    Real-time
    Scalable
    Highly available

Requirements
  Functional
    Newsfeed generation
      Based on pages, groups, followed
      May be many sources
      Generate for all users
      Need to pick & rank content
    Newsfeed content
      Display text, images, videos
    Display
      Affix new incoming posts based on ranking
  Non-functional
    Scalable
      Twitter, FB, Insta
    Fault tolerance
      Partition tolerance necessary
    Availability
      Keep users engaged
      Compromise strong consistency, a la PACELC
    Low latency
      Real-time feed
      No more than 2 s

Resource estimation
  1 billion users/day
  500 DAU
  User has 300 friends, follows 250
  Traffic
    User opens 10x/day
    500m * 10 = 5b requests/day = 58k/second
  Storage
    Feed generated offline, rendered on request
    Precompute top 200 posts/user
    50 KB metadata/user
    1B users = 50 TB for user data
    50 KB / post
    Top 200 posts for 500 m users
    200 * 500m * 50 KB = 5 PB
      (Is this the user's own posts? If feed, just store post IDs...)
    Media content
      1/5 videos
        2 MB
      4/5 images
        200 KB
      200 posts for one user
      200 * 2 MB * 1/5 + 200 * 200 KB * 4/5 = 80 + 32 = 112 MB
      112 MB * 500m = 56 PB
      Need at least 52 PB blob storage
    Servers
      500m/8000 = 62.5 DAU
    Bandwidth
      Not estimated

Building blocks
  Databases 
    Store posts 
    Generated newsfeed
    User metadata
    User relationship
  Cache
    Keep frequently accessed data
  Blob storage
    For media content - images and videos
  CDN 
    Deliver content to end users
  Load balancers

High-level design
  Feed generation
    Aggregate friends & followers posts based on ranking
  Feed publishing
    Write into cache and database
  User makes a post or requests newsfeed
  Load balancer directs traffic to web servers
  Web servers encapsulate back-end services
    Intermediate layer
    Enforce authentication and rate-limiting
    Direct traffic
  Newsfeed generation
    Generates and keeps in cache
  Newsfeed publishing
    From timeline to cache
      Appends thumbnail of media from blog and link
  Post-service
    When user creates post
    Store in post database & cache
    Media content to blob storage

API design
  generateNewsfeed(user_id)
    Take user_id
    Determine friends and followers
    Generate newsfeed of several posts
      Internal system components use
      Call offline to pre-generate
    Persist pre-generated on storage, cache
  getNewsfeed(user_id, count)
    Count is number of items
    (Shouldn't there be an offset? - JM)
  Storage schema
    User
      user_ID       varchar(32)
      Name          varchar(32)
      Email         varchar(32)
      CreationDate  datetime
      Mobile        varchar(32)
      LastLogin     datetime
    Entity
      Entity_ID (primary key)
      Name
      Description (512)
      CreationDate
      Creator (User_ID foreign key)
    Feed_item
      Feed_Item_ID
      Creator
      Content
      Entity_ID
      CreationDate
      Likes_count
      Media_ID
    Media
      Media_ID
      Description
      Path
      Views_count
      CreationDate
    Use a graph database for friend/user/following relationship
      Follow property graph model
        Vertices denote users
        Edges denote relationships
        Edges carry name and relationship properties
      Relational schema for graph store
        PostgreSQL JSON datatype for each vertex & edge
        User
          User_ID
          properties (JSON)
        Relationship
          Relation_ID
          Relation_from (User_ID)
          Relation_towards (User_ID)
          Label
          properties (JSON)

Detailed design
  Generation via service
  When request to retrieve feed is received
    Service called to generate feed for infrequent user
    Pre-generated feed for frequent user
  To generate feed
    Retrieve ID of users/entities followed from graph database
    Get their friend from user cache
    Retrieve latest, most popular, relevant post from IDs from post cache
    Ranking service ranks based on relevance
      (If not doing chrono feed... - JM)
    Newsfeed stored in cache
      Top N posts published to timeline
    Next top N when user scrolls timeline
  How to reduce cache memory usage for creation and storage?
    Store just mapping to posts, fetch from database
      (Yeah I was wondering why we didn't do that earlier)
  Newsfeed publishing
    Fetch posts from cache
    Send constructed newsfeed using fan-out approaches
    Store popular content in CDN
  Why not just create all feeds on the fly?
    Big problem if lots of requests at once
    (Use off-peak hours to generate feeds, smoothing load - JM)
  How to update newsfeed when new post?
    Store in post database and cache
    Feed generation creates new feed for followers and updates cache
    Deliver new feed to users on next update
    (Huh, I would stick it on the front of existing feeds and load via
      polling & "see new" button, seems like a LOT of feed regeneration
      depending on exact service - JM) 
  Newsfeed ranking
    Work on various features - past history, likes, dislikes, comments, clicks, etc.
    Select candidate posts
    Eliminate posts with misinfo or clickbait (oh if only - JM)
    Create list of friends user interacts with
    Choose topics on which user spends more time
    Consider all above poitns to predict relevant and important posts
    Ranking & machine learning algorithms
  Post ranking
    Work on post database
    Assume 10 posts from 5 different users
    Rank 4 out of 10 posts for a user following these 5
    Relevance score assigned 1-5
    Select top posts
    Present in declining order of score assigned
    Computationally intensive
      Big-data processing, specialized hardware
      GPUs
      Tensor processing units (TPUs)
      FB evaluates thousands of features per person

Evaluation
  Scalability
    Can handle ever-increasing
    Components added/removed on demand
  Fault tolerance
    Replication of all data
    Redundant resources always available
  Availability
    Redundant servers, replicated data
    Load balancer to route to servers that are up
    Data stored on different & redundant database clusters
  Low latency
    Geographically distributed servers
    Caching
    CDNs for frequent newsfeeds & media