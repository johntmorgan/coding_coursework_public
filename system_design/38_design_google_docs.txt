Google Docs
  Avoid sending drafts back and forth
  Online collaboration
  Review and comment on document while editing
  No special hardware for newest features
    Just need a browser
  Work from anywhere
  View long-term history, restore older version
  Free
  Competitors
    Etherpad
    MS Office 365
    Slite
  Design in one of two ways
    Centralized, client-server
    Peer-to-peer
    Most commercial solutions use client-server
      We'll focus on that
  64% of people use Google Docs at least once a week!

Requirements
  Functional
    Document collaboration
      Multiple edit simultaneously
      Many users view
    Conflict resolution 
      Push edits by user to other collaborators
      Resolve conflicts editing same portion of document
    Suggestions
      Autocomplete
      Fix grammatical mistakes
    View count
      Editors should be able to view
    History
      See hitory
    More
      Document creation
      Deletion
      Managing user access
      Going to focus on core functionalities above though
  Non-functional
    Latency
      Real-time collaboration
      Challenging when in different regions
    Consistency
      Resolve conflicts during concurrent editing
      Users should all see updated state of document
    Availability
    Scalability
      Both overall users, and viewing single document

Resource estimation
  Assumptions
    80M DAU (isn't that low given the survey above? - JM)
    20 concurrent editors tops
    100 KB document size
    30% contain images - 800 KB each
    2% contain videos - 3MB each
    Each user creates one document/day
  Storage
    80m docs/day
    100 KB + 800 * .3 + .02 * 3000
    32 TB/day
      Images actually dominate storage
    Document history excluded for brevity
  Bandwidth
    Incoming
      32 TB/day uploaded
      32 TB / 86400 * 8 ~= 3 Gbps
    Outgoing
      View 5 documents per day, 5x incoming
      15 Gbps
    Total
      18 Gbps
  Server count
    100 requests/user/day
    92.6k rps
    But not counting rps as sufficient here
    80m/8000k = 10k servers

Building blocks
  Load balancers
  Databases
    Textual content
    Document history
    User data
    Going to need different kinds
  Pub-sub
    Async tasks
  Caching
  Blob storage
  Queueing system
    For user editing operations
  CDN
    Store frequently accessed media
    Frequently requested, read-only docs

Design
  Components
    API gateway
      Different client requests forwarded here
        Single request to multiple
        Reply instantly from cache
    App servers
      Run business logic, high CPU tasks
      File conversion
      Import/export
      Attribute collection for rec engine
    Data stores
      Relational database
        User information
        Doc privilege info
      NoSQL
        User comments, for quicker access
      Time-series
        Edit history
      Blob storage
        Videos and images
      Distributed cache (Redis)/CDN
        Good performance
        Redis stores:
          User sessions
          Typeahead features
          Frequently accessed docs
        CDN stores:
          Frequently accessed docs
          Heavy objects, images & videos
    Processing queue
      Lots of small-sized data (chars) to server
      Queue for periodic batch processing
      Add chars, images, videos, comments to queue
      Use WebSockets
        HTTP call for every char inefficient
        Allows view of live changes to doc by other users
    Other components
      Sessions servers for user session
        Also doc access privileges
      Config
      Monitoring
      Pub-sub
      Logging
    WebSockets advantages
      Long-lasting connection
      Full-duplex communication
        Both client -> server and server -> client
      No HTTP request/response header overhead
    Microservices advantages
      Faster, simpler development
      Each service isolated
        Failure of one does not result in failure of others
      Different components different languages/techs
      Easy to scale & update individually
    Queueing algorithm
      FIFO - keep things in order

  Workflow
    Collaborative editing, conflict resolution
      Request to operations queue
        Resolve conflicts between collab
        If no conflict, batch and store in time series databasae
        Compress videos and images
        Process chars right away
    History
      Time series database
      DIFF operations
    Asynchronous operations
      Notifications
      Emails
      View counts
      Comments
      Pub-sub like Kafka
      Generated by API gateway
    Suggestions
      Typeahead service
      Extract attributes and keywords from within documents
      Lots of words
        Use NoSQL
      Frequently used words and phrases
        Store in cache like Redis
    Import/export documents
      Application servers
    Note
      WebSockets + Redis-like cache = effective chat feature
    What about async for view counts?
      Could do sharded, or Redis counters
      But seems like overkill
      Near real-time?
        Streaming pub-sub, Kafka
          Topic based on document ID
    Where to store view counts?
      NoSQL
        Scalability
        Low read-write latency

Concurrency & collab editing
  What is a document editor?
    Document is chars in order
    Each char has value and positional index
    Editor performs insert(), delete(), edit()
  Concurrency issues
    Due to collab on same document
    What happens when edit same portion?
    Say both insert different words at position 10
    Or both delete the same letter position
      Operations not idempotent
    Solution needs
      Commutativity
        Order of operations does not affect end result
      Idempotency
        Only apply similar operations once
  Techniques
    Operational transformation
      Widely used
      Emerged 1989, improved over time
      Lock-free, non-blocking
      Uses positional index to resolve conflicts
      Consistent if
        Preserve causality
        Converge
          All replicas at different clients identical
      Various models proposed over years
        CC model
        CCI
          Adds intention preservation
        CSM
          Causality, single-op effects, multi-op effects
        CA
          Causality, admissibility
      Two disadvantages
        Each operation may require positional index changes
          Therefore operations are order dependent
        Challenging to develop and implement
          Complex algorithms
          Hard in real world
            Google Wave took 2 years!
    Conflict-free Replicated Data Type (CRDT)
      Improve on OT
      Complex data structure
      Simplified algorithm
      Each char has globally unique identity
      Each char is globally ordered
      Operation data structure
        SiteID - unique
        SiteCounter
        Value - of char
        PositionalIndex - unique position
          May be a fraction
          Avoid changing index of other chars
      Order dependency avoided
      Ensures strong consistency between users
        Even if offline
        Local replicas at end users converge when online
    OT users
      Google Docs
      Etherpad
      Firepad
    CRDTs
      Makes concurrency/consistency easy
      Allows serverless peer-to-peer
    WebSockets also help
      Show collaborator cursor
      Users will naturally avoid conflict
    Why not locks?
      Segment documents into small sections
      Avoid OT and CRDT
      Poor user experience
        What if want to add to same locked section?
      Good choice for Google Sheets
        Doc already divided into small cells
        Only allow one cell edit at a time
    What if user internet speeds differ?
      Order of operations can be a problem
      OT is order dependent
      CRDT is order independent
        Better solution

Evaluation
  Consistency
    Strong via OT and CRDT
    Time-series database to preserve order of events
      Save once OT/CRDT resolves
    Keep document consistent within data center
      Peer-to-peer like Gossip protocol
    Why must be strong and not eventual?
      Automatic reconciliation -> abrupt updates
      Manual resolution -> tedious labor
  Latency
    Feels like a challenge
    User maintain doc replicas locally
    Data propagated through WebSockets to end servers
      User perceived latency low
    Users mostly write text in small documents
      Easy to share among servers in same facility
      Still easy among data centers, zones
    Videos, images in CDN
      Content does not change frequently
    Limited number of readers, usually
      Download only once
      Serve from same data center
    Writers
      Select optimal zone centralized between
    Popular documents
      Asynchronous replication
        Strong consistency becomes challenging though
  Availability
    Replicas, monitor primary & replicas
    Operations queue, data stores internally manage
    WebSocket servers connect to session maint servers
      Determine if user actively viewing document
      Keep multiple WSS
    Caching, CDN
    Disaster-recovery scheme
      Not yet devised
  Scalability
    Microservice
    Scale components individually
    Use multiple operations queues
    Scale horiztonally